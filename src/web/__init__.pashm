#
# web.pashm
#
# The Pashmak Project
# Copyright 2020-2021 parsa shahmaleki <parsampsh@gmail.com>
#
# This file is part of Pashmak.
#
# Pashmak is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pashmak is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pashmak.  If not, see <https://www.gnu.org/licenses/>.
#########################################################################

import @os, @web.session

namespace web

@doc """\
Initializes the web environment.\
"""
func init
    # load the cookies
    if 'HTTP_COOKIE' in list($os.env->keys())
        $items = urllib.parse.parse_qsl($os.env['HTTP_COOKIE'])
        $i = 0
        $cookies = {}
        while $i < len($items)
            $cookies[$items[$i][0]] = $items[$i][1]
            $i = $i + 1
        endwhile
        gset('web.cookies', $cookies)
    else
        gset('web.cookies', {})
    endif

    # parse the GET and POST raw data
    $raw_get = $os.env['QUERY_STRING'] # load the get query string
    $tmp_get = urllib.parse.parse_qsl($raw_get)
    $get = {}

    $i = 0
    while $i < len($tmp_get)
        $get[$tmp_get[$i][0]] = $tmp_get[$i][1]
        $i = $i + 1
    endwhile

    $post = {}
    if $os.env['REQUEST_METHOD'] == 'POST'
        $raw_post = read() # load the post query string

        # keep the raw data
        $os.env['POST_RAW_DATA'] = $raw_post

        # check is the raw post json format
        $is_json = false
        try web_init_check_json_error
            json.loads($raw_post)
            $is_json = true
        endtry
        goto after_web_init_check_json_error; section web_init_check_json_error
            $is_json = false
        section after_web_init_check_json_error

        if $is_json
            $post = json.loads($raw_post)
        else
            $tmp_post = urllib.parse.parse_qsl($raw_post)
            $i = 0
            while $i < len($tmp_post)
                $post[$tmp_post[$i][0]] = $tmp_post[$i][1]
                $i = $i + 1
            endwhile
        endif
    endif

    gset('web.get', $get)
    gset('web.post', $post)

    define('WEB_INITED', true)
    set_header('Content-type', 'text/html')
endfunc

@doc """\
Sets a http header.\n\
First argument is name of header and last is value(both string).\
"""
func set_header(string $name, $value)
    if is_defined('WEB_END_HEADERS')
        raise(Error('HeaderError', 'headers already sent'))
        return
    endif

    print(str($name) + ': ' + str($value) + '\n')
endfunc

@doc """\
Sets http response code.\n\
Gets code as int.\
"""
func status(int $code)
    set_header('Status', str($code))
endfunc

@doc """\
Sets a HTTP cookie.\n\
Gets options as dictionary.\
"""
func set_cookie(dict $options)
    $options->setdefault('value', '')

    # format options
    $tmp = urllib.parse.urlencode([
        ($options['name'], $options['value'])
    ])->split('=', 1)
    $options['name'] = $tmp[0]
    $options['value'] = $tmp[1]

    $base_cookie = http.cookies.BaseCookie()
    $base_cookie[$options['name']] = $options['value']
    $i = 0
    $keys = list($options->keys())
    while $i < len($keys)
        if $keys[$i] not in ['name', 'value']
            $base_cookie[$options['name']][$keys[$i]] = $options[$keys[$i]]
        endif
        $i = $i + 1
    endwhile
    $output = $base_cookie->output()
    $output = $output->split(':', 1)[-1]->strip()->split('=', 1)
    set_header('Set-Cookie', $output[0]->strip() + '=' + $output[-1])
    $real_cookies = gget('web.cookies')
    $tmp = urllib.parse.parse_qsl($output[0]->strip() + '=' + $output[-1])
    $real_cookies[$tmp[0][0]] = $tmp[0][1]
endfunc

@doc "Ends the headers"
func end_headers()
    println('')
    define('WEB_END_HEADERS', true)
endfunc

endns
