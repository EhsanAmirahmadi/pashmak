#
# stdlib.pashm
#
# The Pashmak Project
# Copyright 2020-2021 parsa shahmaleki <parsampsh@gmail.com>
#
# This file is part of Pashmak.
#
# Pashmak is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pashmak is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pashmak.  If not, see <https://www.gnu.org/licenses/>.
#########################################################################

class Object
    func __init__
    endfunc

    func __str__
        return '[PashmakObject name="' + $this->__name__ + '"]'
    endfunc

    func isinstanceof($args)
        $args = format_args($args)
        $class = $args[0]
        if typeof($class) != str
            $class = $class->__name__
        endif

        return $class in $this->__inheritance_tree__
    endfunc
endclass

func print
    mem self.print(^)
endfunc

func import
    mem self.import_script(^)
endfunc

func import_once
    mem self.import_script(^, True)
endfunc

func exit($args)
    $args = format_args($args)
    $code = $args[0]
    if typeof($code) != int
        $code = 0
    endif
    python("self.exit_program(self.get_var('code'))")
endfunc

func eval
    mem self.pashmak_eval(^)
endfunc

func endns
    endnamespace
endfunc

func raise($args)
    $args = format_args($args)
    $ex = $args[0]
	python("self.raise_error('" + str($ex->type) + "', '" + str($ex->message) + "')")
endfunc

func assert($args)
    $args = format_args($args)
    $value = $args[0]
    if not $value
        raise(Error('AssertError', 'asserting that false is true'))
    endif
endfunc

func gset($args)
    $args = format_args($args)
	python('self.frames[0]["vars"]["' + str($args[0]) + '"] = self.get_var("args")[1]')
endfunc

func println($value)
    print(str($value) + '\\n')
endfunc

func printl($value)
    println($value)
endfunc

# prints on stderr
func perror($value)
    mem self.print($value, file=sys.stderr)
endfunc

func typeof($obj)
    python("self.mem = type(self.get_var('obj'))")
endfunc

func system($args)
    $args = format_args($args)
    $cmd = $args[0]
    python("self.mem = os.system(self.get_var('cmd'))")
endfunc

func python
    rmem exec(^)
endfunc

func required
endfunc

func read
    python("self.io_read()")
endfunc

func py_load_file($args)
    $args = format_args($args)
    $path = $args[0]
	python("import importlib.util; spec = importlib.util.spec_from_file_location('pyloadedfile', self.get_var('path')); m = importlib.util.module_from_spec(spec); spec.loader.exec_module(m); self.mem = m")
endfunc

func fopen($args)
    $args = format_args($args)
    $path = $args[0]
    if len($args) > 1
        $type = $args[1]
    else
        $type = 'r'
    endif

    python("self.mem = open(self.get_var('path'), self.get_var('type'))")
endfunc

class Error
    $type
    $messae

    func __init__($args)
        $args = format_args($args)
        $this->type = $args[0]
        $this->message = $args[1]
    endfunc

    func __str__
        return $this->type + ': ' + $this->message
    endfunc
endclass

# The function super tools
namespace func
    func list
        # returns list of functions
        python("self.mem = list(self.functions.keys())")
    endfunc

    func exists($args)
        $args = format_args($args)
        $name = $args[0]
        # checks a function exists or not
        $name = str($name)
        return $name in func.list()
    endfunc

    func delete($args)
        $args = format_args($args)
        $name = $args[0]
        # deletes a function
        $name = str($name)
        if not func.exists($name)
            raise(Error('FunctionNotFound', 'function "' + $name + '" not found'))
            return
        endif

        $undeletable_functions = ['func.list', 'func.delete', 'func.exists', 'gset', 'py_load_file', 'system', 'typeof', 'required', 'print', 'import', 'println', 'printl', 'import_once', 'mem', 'rmem', 'python', 'endns', 'exit', 'eval', 'raise', 'assert', 'read'] # list of undeletable functions
        if $name in $undeletable_functions
            raise(Error('FunctionCannotBeDeleted', 'function "' + $name + '" is a builtin function and cannot be deleted'))
        endif

        # delete the function
        python("del self.functions[self.get_var('name')]")
    endfunc
endns

# The class super tools
namespace class
    func list
        # returns list of classes
        python("self.mem = list(self.classes.keys())")
    endfunc

    func exists($args)
        $args = format_args($args)
        $name = $args[0]
        # checks a class exists or not
        $name = str($name)
        return $name in class.list()
    endfunc

    func delete($args)
        $args = format_args($args)
        $name = $args[0]
        # deletes a class
        $name = str($name)
        if not class.exists($name)
            raise(Error('ClassNotFound', 'class "' + $name + '" not found'))
            return
        endif

        $undeletable_classes = ['Object', 'Error'] # list of undeletable classes
        if $name in $undeletable_classes
            raise(Error('ClassCannotBeDeleted', 'class "' + $name + '" is a builtin class and cannot be deleted'))
        endif

        # delete the class
        python("del self.classes[self.get_var('name')]")
    endfunc
endns

func out_start
    python("self.out_started = True")
endfunc

func out_end
    python("self.out_started = False")
endfunc

func out_clean
    python("self.out_content = ''")
endfunc

func out_get
    python("self.mem = self.out_content")
endfunc

func out_get_clean
    $content = out_get()
    out_clean()
    return $content
endfunc

func __namespace__
    python("self.mem = self.current_namespace()")
endfunc

func var_dump($obj)
    python("class Tmp:\\n    def write(self, value):\\n        current_prog.current_prog.print(str(value))\\npprint.pprint(self.get_var('obj'), Tmp())")
endfunc

func format_args($args)
    if type($args) != tuple
        $args = $args,
    endif

    return $args
endfunc

func printf($args)
    $args = format_args($args)
    $obj = $args[0]
    $file = python("self.mem = sys.stdout")
    if len($args) > 1
        $file = $args[1]
    endif

    $file->write(str($obj))
endfunc

namespace pashmak
    func zen
        println('Zen of Pashmak\\n\\
\\n\\
The Zen of Pashmak is a collection of "guiding principles" for writing computer programs that influence the design of the Pashmak programming language. (Like zen of python). This fucking list is written by Mohammad Esmaeili.\\n\\
\\n\\
    Fucking syntax is better than beautiful syntax\\n\\
    English is better than Finglish\\n\\
    Lossless slow is better than loosing fast\\n\\
    CatShit is better than DogShit\\n\\
    DogShit is better than BullShit\\n\\
    Chaos is better than peace\\n\\
    Enthropy is better than order\\n\\
    Crazy is better than logic\\n\\
    Fun is better than boring\\n\\
    Happy is better than sad\\n\\
    Pashm is better than Hash\\n\\
    While is better than Do-While\\n\\
    Space is better than Tab\\n\\
    Also tab is better than Space\\n\\
    -> is better than .\\n\\
    if-else is better than switch-case')
    endfunc
endns

